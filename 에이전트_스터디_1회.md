# LLM 에이전트 스터디 1회차 모임 정리

## 1. LLM과 에이전트(Agent)의 관계

* **LLM의 위치:** LLM은 결국 에이전트의 일부일 뿐임.
* **에이전트의 구성 요소:** LLM + 툴(Tools) + 메모리(Memory) + 프롬프트(Prompts).
* **워크플로우 설계의 핵심:** 단순히 LLM만 사용하는 것이 아니라, 툴을 더 제공할지, 메모리를 확장할지, 프롬프팅을 정교하게 할지 등 구성 요소 간의 밸런스를 설계하는 것이 중요함.

## 2. 프롬프트 엔지니어링에 대한 고찰

* **함수 호출(Function Calling):** 함수 네이밍을 명확히 하고, LLM이 Description을 보고 작업을 수행하게 하는 과정이 중요함.
* **프롬프팅의 변화:**
* 최신 모델에서는 복잡한 기교를 부리는 프롬프팅의 중요도가 다소 낮아짐.
* 오히려 구조화된 지시(XML 형식 등)와 배경지식을 제공하는 것이 성능 향상에 도움됨.


* **자동화와 템플릿(Recipe):**
* 일반적인 대화보다 특정 업무 자동화(보고서 작성, 포맷 준수 등)를 위해서는 여전히 프롬프팅이 중요함.
* Meta에서는 이를 '레시피(Recipe)'라고 칭함. (예: 특정 테이블 크기, Syntax에 맞춰 구글 Docs 생성)
* AI에게 작업을 시키는 방법을 정의하여, AI가 다시 AI에게 일을 시키는 구조로 발전.



## 3. 에이전트의 역할과 생성형 AI의 확장

* **구조적 관점:** 어시스턴트의 역할 분담이 마치 컴퓨터 아키텍처를 보는 것과 유사함.
* **단순 답변을 넘어선 생성:**
* 기존 RAG(검색 증강 생성)가 문서(PDF, XLSX)를 보고 답변하는 데 치중했다면, 이제는 이를 바탕으로 새로운 산출물(PPT 등)을 만들어내는 단계로 진입.
* OpenClaw 등 미래의 기술로 여겨지던 것들이 실무 영역으로 다가옴.


* **실무적 고민:** 도입 시 보안 및 비용 관리 이슈에 대한 고려 필요.

## 4. RAG(검색 증강 생성)의 유효성 논쟁

* **"RAG is Dead?"**
* **회의론:** LLM의 Context Window(문맥 길이)가 비약적으로 늘어나면서, 굳이 RAG를 구축할 필요가 없다는 의견 존재.
* **반론:** 아무리 Context가 늘어도 모든 정보를 담을 수는 없음(예: 방대한 코드베이스, 실시간 데이터).


* **대안 및 절충안:**
* 코딩 에이전트의 경우 전체 코드를 Context에 넣는 대신, '검색 툴'을 쥐어주어 필요한 부분만 찾아보게 하는 방식 사용.



## 5. 최적화와 새로운 엔지니어링

* **ReAct 방식의 비용 문제:** 에이전트가 스스로 판단(ReAct)하는 과정에서 토큰 소모가 크고, 불필요한 툴을 사용할 위험이 있음.
* **새로운 프롬프트 엔지니어링:** 에이전트에게 **"어떤 상황에서 어떤 도구를 쓰게 할 것인가"**를 제어하고 최적화하는 것이 현대적인 프롬프트 엔지니어링의 핵심.